{"version":3,"sources":["../../src/swc/sources.ts"],"sourcesContent":["import glob from \"fast-glob\";\nimport slash from \"slash\";\nimport { stat } from \"fs\";\nimport { join, basename, extname } from \"path\";\n\n/**\n * Find all input files based on source globs\n */\nexport async function globSources(\n  sources: string[],\n  includeDotfiles = false\n): Promise<string[]> {\n  const globConfig = {\n    dot: includeDotfiles,\n    nodir: true,\n  };\n\n  const files = await Promise.all(\n    sources\n      .filter(source => includeDotfiles || !basename(source).startsWith(\".\"))\n      .map(source => {\n        return new Promise<string[]>(resolve => {\n          stat(source, (err, stat) => {\n            if (err) {\n              resolve([]);\n              return;\n            }\n            if (!stat.isDirectory()) {\n              resolve([source]);\n            } else {\n              glob(slash(join(source, \"**\")), globConfig)\n                .then(matches => resolve(matches))\n                .catch(() => resolve([]));\n            }\n          });\n        });\n      })\n  );\n\n  return Array.from(new Set<string>(files.flat()));\n}\n\ntype Split = [compilable: string[], copyable: string[]];\n\n/**\n * Test if a filename ends with a compilable extension.\n */\nexport function isCompilableExtension(\n  filename: string,\n  allowedExtension: string[]\n): boolean {\n  const ext = extname(filename);\n  return allowedExtension.includes(ext);\n}\n\n/**\n * Split file list to files that can be compiled and copied\n */\nexport function slitCompilableAndCopyable(\n  files: string[],\n  allowedExtension: string[],\n  copyFiles: boolean\n): Split {\n  const compilable: string[] = [];\n  const copyable: string[] = [];\n\n  for (const file of files) {\n    const isCompilable = isCompilableExtension(file, allowedExtension);\n\n    if (isCompilable) {\n      compilable.push(file);\n    } else if (copyFiles) {\n      copyable.push(file);\n    }\n  }\n\n  return [compilable, copyable];\n}\n\nexport async function requireChokidar() {\n  try {\n    const { default: chokidar } = await import(\"chokidar\");\n    return chokidar;\n  } catch (err) {\n    console.error(\n      \"The optional dependency chokidar is not installed and is required for \" +\n        \"--watch. Chokidar is likely not supported on your platform.\"\n    );\n    throw err;\n  }\n}\n\nexport async function watchSources(sources: string[], includeDotfiles = false) {\n  const chokidar = await requireChokidar();\n\n  return chokidar.watch(sources, {\n    ignored: includeDotfiles\n      ? undefined\n      : (filename: string) => basename(filename).startsWith(\".\"),\n    ignoreInitial: true,\n    awaitWriteFinish: {\n      stabilityThreshold: 50,\n      pollInterval: 10,\n    },\n  });\n}\n"],"names":["globSources","isCompilableExtension","slitCompilableAndCopyable","requireChokidar","watchSources","sources","includeDotfiles","globConfig","dot","nodir","files","Promise","all","filter","source","startsWith","map","resolve","err","stat","isDirectory","then","matches","catch","Array","from","Set","flat","filename","allowedExtension","ext","includes","copyFiles","compilable","copyable","file","isCompilable","push","default","chokidar","console","error","watch","ignored","undefined","ignoreInitial","awaitWriteFinish","stabilityThreshold","pollInterval"],"mappings":"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"}